#!/usr/bin/env node

import { writeFile, mkdir } from 'node:fs/promises';
import { dirname } from 'node:path';

const BASE = 'https://help.thegamecrafter.com';

const CATEGORIES = [
  { name: 'Getting Started', url: `${BASE}/category/4-getting-started` },
  { name: 'Frequently Asked Questions', url: `${BASE}/category/71-frequently-asked-questions` },
  { name: 'File Preparation', url: `${BASE}/category/10-file-preparation` },
  { name: 'Game Editor', url: `${BASE}/category/11-game-editor` },
  { name: 'Production', url: `${BASE}/category/12-production` },
  { name: 'Design Tools & Artwork', url: `${BASE}/category/197-design-tools-artwork` },
];

const OUTPUT_JSON = '/home/khenny/tgcmcp/skills/tgc-guided-workflows/references/tgc-help-center-catalog.json';
const OUTPUT_MD = '/home/khenny/tgcmcp/skills/tgc-guided-workflows/references/tgc-help-center-catalog.md';

function stripTags(input) {
  return input
    .replace(/<script[\s\S]*?<\/script>/gi, ' ')
    .replace(/<style[\s\S]*?<\/style>/gi, ' ')
    .replace(/<[^>]+>/g, ' ')
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/\s+/g, ' ')
    .trim();
}

function normalizeUrl(href) {
  if (!href) return '';
  if (href.startsWith('http://') || href.startsWith('https://')) return href;
  if (href.startsWith('/')) return `${BASE}${href}`;
  return `${BASE}/${href}`;
}

async function fetchHtml(url) {
  const maxAttempts = 5;
  let attempt = 0;
  while (attempt < maxAttempts) {
    attempt += 1;
    const res = await fetch(url, {
      headers: {
        'user-agent': 'tgcmcp-help-crawler/1.0 (+https://github.com/khenn/thegamecrafter-mcp)',
        accept: 'text/html,application/xhtml+xml',
      },
    });
    if (res.ok) {
      return await res.text();
    }
    const status = res.status;
    if (status !== 429 && status < 500) {
      throw new Error(`Fetch failed ${status} for ${url}`);
    }
    if (attempt >= maxAttempts) {
      throw new Error(`Fetch failed ${status} after ${maxAttempts} attempts for ${url}`);
    }
    const waitMs = 500 * attempt * attempt;
    await sleep(waitMs);
  }
  throw new Error(`Fetch failed for ${url}`);
}

function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function parseCategoryPage(html) {
  const articleRegex = /<li>\s*<a\s+href="([^"]*\/article\/[^"]+)"[^>]*>\s*(?:<i[^>]*><\/i>)?\s*<span>([\s\S]*?)<\/span>\s*<\/a>\s*<\/li>/g;
  const pageRegex = /href="([^"]*\/category\/[0-9]+(?:\/[0-9]+)?\?sort=popularity)"/g;

  const articles = [];
  const pages = new Set();

  let m;
  while ((m = articleRegex.exec(html)) !== null) {
    const url = normalizeUrl(m[1]);
    const title = stripTags(m[2]);
    if (url && title) {
      articles.push({ title, url });
    }
  }

  while ((m = pageRegex.exec(html)) !== null) {
    const url = normalizeUrl(m[1]);
    if (url) pages.add(url);
  }

  return { articles, pages: [...pages] };
}

function parseArticle(html, url) {
  const titleMatch = html.match(/<h1\s+class="title">([\s\S]*?)<\/h1>/i);
  const title = titleMatch ? stripTags(titleMatch[1]) : url;

  const articleBodyMatch = html.match(/<article\s+id="fullArticle">([\s\S]*?)<\/article>/i);
  const body = articleBodyMatch ? articleBodyMatch[1] : html;

  const pRegex = /<p>([\s\S]*?)<\/p>/gi;
  const paragraphs = [];
  let p;
  while ((p = pRegex.exec(body)) !== null) {
    const text = stripTags(p[1]);
    if (text) paragraphs.push(text);
    if (paragraphs.length >= 3) break;
  }

  const summary = paragraphs.join(' ').slice(0, 500);
  return { title, summary };
}

function toMarkdown(data) {
  const lines = [];
  lines.push('# TGC Help Center Catalog (Seeded Categories)');
  lines.push('');
  lines.push('Generated by `code/scripts/crawl-tgc-help-center.mjs`.');
  lines.push('');
  lines.push('## Included Categories');
  for (const c of data.categories) {
    lines.push(`- [${c.name}](${c.url}) (${c.articleCount} articles)`);
  }
  lines.push('');
  lines.push('## Article Index');
  lines.push('');

  for (const c of data.categories) {
    lines.push(`### ${c.name}`);
    for (const a of c.articles) {
      lines.push(`- [${a.title}](${a.url})`);
    }
    lines.push('');
  }

  lines.push('## Quick Summaries (first-paragraph extraction)');
  lines.push('');
  for (const c of data.categories) {
    lines.push(`### ${c.name}`);
    for (const a of c.articles.slice(0, 15)) {
      if (a.summary) {
        lines.push(`- **${a.title}**: ${a.summary}`);
      } else {
        lines.push(`- **${a.title}**: (No summary extracted)`);
      }
    }
    lines.push('');
  }

  return `${lines.join('\n')}\n`;
}

async function main() {
  const categoryResults = [];
  const articleSeen = new Map();

  for (const category of CATEGORIES) {
    const queue = [category.url];
    const visited = new Set();
    const articles = new Map();

    while (queue.length > 0) {
      const url = queue.shift();
      if (!url || visited.has(url)) continue;
      visited.add(url);

      const html = await fetchHtml(url);
      await sleep(250);
      const parsed = parseCategoryPage(html);

      for (const a of parsed.articles) {
        if (!articles.has(a.url)) {
          articles.set(a.url, { ...a, summary: '' });
        }
      }

      for (const p of parsed.pages) {
        if (!visited.has(p)) queue.push(p);
      }
    }

    categoryResults.push({
      name: category.name,
      url: category.url,
      articleUrls: [...articles.keys()],
      articles,
    });

    for (const url of articles.keys()) {
      if (!articleSeen.has(url)) {
        articleSeen.set(url, { title: '', summary: '' });
      }
    }
  }

  for (const [url] of articleSeen) {
    try {
      const html = await fetchHtml(url);
      await sleep(250);
      const parsed = parseArticle(html, url);
      articleSeen.set(url, parsed);
    } catch (error) {
      articleSeen.set(url, { title: url, summary: '' });
    }
  }

  const categories = categoryResults.map((c) => {
    const merged = c.articleUrls
      .map((url) => {
        const parsed = articleSeen.get(url) || { title: '', summary: '' };
        return {
          url,
          title: parsed.title || c.articles.get(url)?.title || url,
          summary: parsed.summary,
        };
      })
      .sort((a, b) => a.title.localeCompare(b.title));
    return {
      name: c.name,
      url: c.url,
      articleCount: merged.length,
      articles: merged,
    };
  });

  const out = {
    generatedAt: new Date().toISOString(),
    sourceCategories: CATEGORIES,
    totalArticles: [...articleSeen.keys()].length,
    categories,
  };

  await mkdir(dirname(OUTPUT_JSON), { recursive: true });
  await writeFile(OUTPUT_JSON, `${JSON.stringify(out, null, 2)}\n`, 'utf8');
  await writeFile(OUTPUT_MD, toMarkdown(out), 'utf8');

  console.log(`Wrote ${OUTPUT_JSON}`);
  console.log(`Wrote ${OUTPUT_MD}`);
  console.log(`Total unique articles: ${out.totalArticles}`);
}

main().catch((error) => {
  console.error(error?.message || error);
  process.exit(1);
});
